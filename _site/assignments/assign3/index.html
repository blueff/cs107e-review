<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="/_assets/site.css" rel="stylesheet">
    <link href="/_assets/favicon.png" rel="icon" type="image/png">
    <title>CS107E Assignment 3: Implement a String Formatting Library</title>
  </head>

<body>
  <!-- Include this HTML partial to set up navbar -->

<nav class="navbar navbar-inverse" role="navigation">
  <div class="navbar-header">
  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
    <!-- hamburger -->
    <span class="sr-only">Toggle navigation</span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>

  <img class="navbar-brand navbar-brand-image" src="/_assets/berry.png" >
  <a class="navbar-brand" href="/">CS107e Winter 2020</a>
  </div>

  <div class="navbar-collapse collapse">
    <ul class="nav navbar-nav navbar-right">
      <li><a href="/">Home</a></li>
      <li><a href="/assignments">Assignments</a></li>
      <li><a href="/labs">Labs</a></li>
      <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="#">
            Resources
          <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="/about/">About the course</a></li>
            <li><a href="/policies/">Policies</a></li>
            <li><a href="/schedule/">Schedule</a></li>
            <li><a href="/guides/">Guides</a></li>
            <li><a href="/project_gallery/">Project gallery</a></li>
            <li><a href="/demos/">External demos</a></li>
            <li><a href="/resources/">External resources</a></li>
          </ul>
        </li>
      <li><a href="https://github.com/cs107e/cs107e.github.io">Repository</a></li>
    </ul>
  </div>
</nav>


  <div class="container" style="max-width:55em;">
    <h1 class="title">Assignment 3: Implement a String Formatting Library</h1><hr>
    
  <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="main_for_toc">
    
<p><em>Written by Pat Hanrahan and Julie Zelenski</em></p>

<!-- If duedate set in front_matter, use that, otherwise calculate based on n*weeks + assign1 due -->

<p><b>Due: Tuesday, February 04 at  6:00 pm</b></p>

<h2 id="goals">Goals</h2>

<p>Libraries are critical in software development. They let you build
on existing, well-designed, and well-tested abstractions.
Many of the C standard libraries are
surprisingly large. Because we copy our entire program over a slow
serial line to the bootloader, we want a smaller, simpler library of just the essentials. The library you will implement supports a subset of the standard features selected for their utility and relevance to our particular needs.</p>

<p>A library for outputting formatted text is particularly powerful,
since printing program state is a valuable form of debugging. In C, the
standard function to output formatted text is <code class="highlighter-rouge">printf</code>. The standard version of <code class="highlighter-rouge">printf</code> has many options and a large code size.  You will implement a
pared-down <code class="highlighter-rouge">printf</code> that provides just the essential core functionality. Your <code class="highlighter-rouge">printf</code> will be layered on a <code class="highlighter-rouge">strings</code> module that you will also write.
Completing this assignment will give you two new modules to add to your growing library of Raspberry Pi functions.</p>

<p>In addition to having extended your library with this extremely useful functionality, by implementing these
functions you will learn:</p>

<ul>
  <li>how to decompose a complex programming problem into smaller and more manageable pieces,</li>
  <li>how strings and characters are represented and manipulated in C,</li>
  <li>how to convert basic C types (numbers, pointers) to a string representation,</li>
  <li>how to reuse your GPIO and timer code from the previous assignment, and</li>
  <li>how to use the UART library shown in class to communicate with your laptop.</li>
</ul>

<h2 id="advice">Advice</h2>

<p>This is a difficult assignment, so‚Ä¶</p>

<ol>
  <li><strong>Mindset</strong>. Your skills with memory-wrangling and C pointers will grow leaps and bounds in completing this assignment, but you will work hard for it and you‚Äôre likely to encounter some tough bugs along the way. You can do this!  If you start to lose momentum, reach out for help and we can get you back on track.</li>
  <li><strong>Start early</strong>. This gives you time to think things through, to take advantage of office hours, to take a break and clear your head when stalled, to back out from a decision that didn‚Äôt work out, to pause and appreciate all that you are learning.  In contrast, getting a late start means working non-stop under the unpleasant stress of a looming deadline.</li>
  <li><strong>Follow good development and debugging practice</strong>, just like you learned in lab. Now is the time to build up your mad gdb skills. Take to heart our recommended <a href="#strategies-for-success">Strategies for Success</a>. This will help you complete the assignment more efficiently and with less strife.</li>
  <li><strong>Test as you go</strong>. Spending 10 minutes to write a test
can save you hours of debugging time later.</li>
  <li><strong>Commit often</strong>. If you modify your code and break it you can easily go back to a working version.</li>
</ol>

<p>We know this assignment is a big step up, and you will learn a tremendous amount in completing it. We have many quarters of experience helping students succeed on this assignment, and we know you can triumph! But please, please, please follow our recommendations so you can not only end with a satisfying result, but also have an enjoyable journey.</p>

<h2 id="get-starter-files">Get starter files</h2>
<p>Change to the <code class="highlighter-rouge">cs107e.github.io</code> repository in your <code class="highlighter-rouge">cs107e_home</code> and do a <code class="highlighter-rouge">git pull</code> to ensure your courseware files are up to date.</p>

<p>To get the assignment starter code, change to your local repository, fetch any changes from the remote and switch to the assignment basic branch:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/cs107e_home/assignments
$ git fetch origin
$ git checkout assign3-basic
</code></pre></div></div>

<p>Each subsequent assignment starts from where you left off, so the <code class="highlighter-rouge">assign3-basic</code> branch contains the <code class="highlighter-rouge">gpio.c</code>
and <code class="highlighter-rouge">timer.c</code> files you submitted for the previous assignment. You have the option of building on your own code as you move forward or switching out your modules for our library versions. Which modules of yours are used and which of ours is controlled by the setting <code class="highlighter-rouge">MY_MODULES</code> in the Makefile. Read the <code class="highlighter-rouge">Makefile</code> for information on how to configure this setting.</p>

<p>The starter code contains the files <code class="highlighter-rouge">printf.c</code> and <code class="highlighter-rouge">strings.c</code>, a sample application <code class="highlighter-rouge">apps/print_pinout.c</code> and the test program <code class="highlighter-rouge">tests/test_strings_printf.c</code>.</p>

<p>You will edit the <code class="highlighter-rouge">strings.c</code> and <code class="highlighter-rouge">printf.c</code> files to implement the required
functions.  You will also add many tests to <code class="highlighter-rouge">tests/test_strings_printf.c</code>.  The <code class="highlighter-rouge">apps/print_pinout.c</code> is a small sample application that uses <code class="highlighter-rouge">printf</code> to display the Pi‚Äôs pinout. <strong>Do not modify <code class="highlighter-rouge">apps/print_pinout.c</code>.</strong></p>

<p>The <code class="highlighter-rouge">make install</code> target of the Makefile builds and run the sample application <code class="highlighter-rouge">apps/print_pinout.bin</code>. The <code class="highlighter-rouge">make test</code> target builds and run the test program <code class="highlighter-rouge">tests/test_strings_printf.bin</code>. Remember that you can run the debugger in simulator mode on the corresponding ELF file, e.g. <code class="highlighter-rouge">arm-none-eabi-gdb tests/test_strings_printf.elf</code>.</p>

<h2 id="basic-section">Basic section</h2>

<p>Below we introduce the modules by giving an rundown of the functions and their specifications. We recommend you skim through this section to get an overview but don‚Äôt get too lost in the nitty-gritty just yet. When ready to get cracking on the coding, start by bringing your full attention to the <a href="#stragies-for-success">Strategies for Success</a> section where we give a road map and advice on how to proceed. You can postpone serious study of the minute details of the function specifications until you are deeper into the implementation phase.</p>

<h3 id="strings-module">Strings module</h3>
<p>Every general purpose programming language supports a string data type and operations. 
The string type in C is very bare bones; simply a pointer to a contiguous sequence of characters terminated by a null character (zero, or <code class="highlighter-rouge">'\0'</code>). You can access individual characters using pointer or array operations and that‚Äôs about it. To do more useful things with a C-string, such as find its length, make a copy, or compare two strings, you must write functions to do so. Use the command <code class="highlighter-rouge">man string</code> to list the functions from the standard C  <code class="highlighter-rouge">strings</code> module. There are a lot of functions in the standard library!</p>

<p>You will implement your own <code class="highlighter-rouge">strings</code> module for the Pi. The module will not include such a large set of operations, just a few key essentials chosen for their specific usefulness to us.</p>

<p>The string functions you are to implement in <code class="highlighter-rouge">strings.c</code> are:</p>

<ul>
  <li><code class="highlighter-rouge">memset</code></li>
  <li><code class="highlighter-rouge">memcpy</code></li>
  <li><code class="highlighter-rouge">strlen</code></li>
  <li><code class="highlighter-rouge">strcmp</code></li>
  <li><code class="highlighter-rouge">strlcat</code></li>
  <li><code class="highlighter-rouge">strtonum</code></li>
</ul>

<p>Review our <a href="https://github.com/cs107e/cs107e.github.io/blob/master/cs107e/include/strings.h">strings.h</a> file to learn the operation of each
function.  Although our function interfaces are modeled after similarly-named functions in the
standard C library, we have made some simplifications, so please read our header file
carefully to ensure you are implementing only and exactly what is
expected.</p>

<p>The choice of these particular six functions may appear eclectic, but each was selected for its utility in implementing or testing <code class="highlighter-rouge">printf</code>. As you implement each string function, consider how to properly use it and what it will be useful for. In particular, <code class="highlighter-rouge">strlcat</code> may seem oddly-structured at first glance, but its specific functionality turns out to be an ideal match for certain tasks within <code class="highlighter-rouge">printf</code>.</p>

<h3 id="printf-module">Printf module</h3>

<p>The functions in the <code class="highlighter-rouge">printf</code> module construct formatted strings in preparation for writing those strings to a terminal or a file.</p>

<p>The three public functions you are to implement in <code class="highlighter-rouge">printf.c</code> are:</p>
<ul>
  <li><code class="highlighter-rouge">printf</code></li>
  <li><code class="highlighter-rouge">snprintf</code></li>
  <li><code class="highlighter-rouge">vsnprintf</code></li>
  <li>These two private helper functions are also expected to be part of your implementation:
    <ul>
      <li><code class="highlighter-rouge">unsigned_to_base</code></li>
      <li><code class="highlighter-rouge">signed_to_base</code></li>
    </ul>
  </li>
</ul>

<p>Review our <a href="https://github.com/cs107e/cs107e.github.io/blob/master/cs107e/include/printf.h">printf.h</a> file for documentation of the public functions and see the starter file <code class="highlighter-rouge">printf_internal.h</code> for the private helpers. The required feature set is simplified from the standard C library version, please read our header file carefully to ensure you are implementing only and exactly what is expected.</p>

<p>The printf module is not really so much about output; the work is almost entirely string manipulation. The fundamental task is to process an input  string and its embedded formatting codes and expand into a fully fleshed-out output string.</p>

<h4 id="number-to-string-conversion-helpers">Number to string conversion helpers</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">unsigned_to_base</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_width</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">signed_to_base</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_width</span><span class="p">);</span>
</code></pre></div></div>

<p>These helper functions convert a numeric value to a string representation in a particular base. For example, given the integer value <code class="highlighter-rouge">126</code>, its string representation in base 10 is the sequence of four ASCII characters <code class="highlighter-rouge">1</code> <code class="highlighter-rouge">2</code> <code class="highlighter-rouge">6</code> <code class="highlighter-rouge">\0</code>, i.e. the string <code class="highlighter-rouge">"126"</code>. The string representation of <code class="highlighter-rouge">126</code> in base 16 would be <code class="highlighter-rouge">"7e"</code>.</p>

<p>The <code class="highlighter-rouge">val</code> argument is the integer value to convert.
If <code class="highlighter-rouge">signed_to_base</code> is called with a negative value, the output string will contain a leading minus sign.</p>

<p>The <code class="highlighter-rouge">base</code> argument indicates whether the output string is to be represented in
decimal (base 10) or hexadecimal (base 16).</p>

<p>The <code class="highlighter-rouge">min_width</code> is the minimum number of characters in the output string.  If 
the output string contains fewer characters than <code class="highlighter-rouge">min_width</code>, the output string is padded with leading zeros to bring it up to length <code class="highlighter-rouge">min_width</code>. If the 
output string is already at least as long as <code class="highlighter-rouge">min_width</code>, the <code class="highlighter-rouge">min_width</code>
argument is ignored. The minus sign should precede the zero padding and is included
in the <code class="highlighter-rouge">min_width</code>. You can assume <code class="highlighter-rouge">min_width</code> is non-negative.</p>

<p>The caller supplies the arguments <code class="highlighter-rouge">buf</code> and <code class="highlighter-rouge">bufsize</code>. <code class="highlighter-rouge">buf</code> is the address of the character array where the output string is to be written. <code class="highlighter-rouge">bufsize</code> is the size of the array. The functions must respect this size and never write more characters that fit in <code class="highlighter-rouge">buf</code>. If the output string would be too long, truncate to what fits, being sure to reserve one slot for the null terminator. The contents written to <code class="highlighter-rouge">buf</code> must be a valid, null-terminated string.</p>

<p>The return value is the count of characters written to <code class="highlighter-rouge">buf</code> if there is space to fit the entire output string. If not, it returns
the count of characters that would have been written if there
were space. The null terminator is not included in the count.</p>

<p>Some examples (<code class="highlighter-rouge">'\0'</code> is the null terminator):</p>

<ul>
  <li><code class="highlighter-rouge"> signed_to_base(buf, 20, 35, 10, 0) </code> writes 3 bytes into buf: <code class="highlighter-rouge">3</code> <code class="highlighter-rouge">5</code>  <code class="highlighter-rouge">\0</code> and returns 2.</li>
  <li><code class="highlighter-rouge">unsigned_to_base(buf, 20, 35, 16, 4)</code> writes 5 bytes into buf: <code class="highlighter-rouge">0</code> <code class="highlighter-rouge">0</code> <code class="highlighter-rouge">2</code> <code class="highlighter-rouge">3</code> <code class="highlighter-rouge">\0</code> and returns 4.</li>
  <li><code class="highlighter-rouge">signed_to_base(buf, 5, -9999, 10, 6)</code> writes 5 bytes into buf: <code class="highlighter-rouge">-</code> <code class="highlighter-rouge">0</code> <code class="highlighter-rouge">9</code> <code class="highlighter-rouge">9</code> <code class="highlighter-rouge">\0</code> and returns 6.</li>
</ul>

<p><strong>Note about bufsize and memory corruption:</strong>
You might notice that some of these parameters overlap in what they specify about
the output string. For example, <code class="highlighter-rouge">bufsize</code> is a hard upper limit on how much space is 
available to store the output string, but nothing in the calling convention says that
<code class="highlighter-rouge">min_width</code> must fit within <code class="highlighter-rouge">bufsize</code>. In all cases <code class="highlighter-rouge">bufsize</code> wins: not writing past the end
of <code class="highlighter-rouge">buf</code> and not corrupting memory is more important than writing out the string specified
by the arguments.  If <code class="highlighter-rouge">bufsize</code> is too small to fit your output, even if <code class="highlighter-rouge">min_width</code> says you 
should go past it, you must truncate the output and store a null terminator in <code class="highlighter-rouge">buf[bufsize - 1]</code>. 
Finally, <code class="highlighter-rouge">bufsize</code> can be zero: if so, you should not write anything to <code class="highlighter-rouge">buf</code>, not even a 
null terminator.</p>

<h4 id="snprintf-and-family"><code class="highlighter-rouge">snprintf</code> and family</h4>

<p><img src="images/snprintf.png" width="120" /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
<span class="kt">int</span> <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
</code></pre></div></div>
<p>These three functions of the printf family each accept the same type of input strings and formatting codes, but differ slightly in how they are called or where the output is written.</p>

<p>The ‚Äúformatting codes‚Äù allow combining different types of values into a single output string. Review this <a href="http://www.cplusplus.com/reference/cstdio/printf/#example">C reference</a> for sample uses of <code class="highlighter-rouge">printf</code>. The default <code class="highlighter-rouge">printf</code> writes the formatted output to your terminal; the <code class="highlighter-rouge">snprintf</code> variant writes the formatted output to a string buffer. In the final arrangement, the workhorse <code class="highlighter-rouge">vnprintf</code> will underly both <code class="highlighter-rouge">printf</code> and <code class="highlighter-rouge">snprintf</code>.</p>

<p>Full documentation for any standard C function is available in its man page, e.g. <code class="highlighter-rouge">man snprintf</code>. Bear in mind that your implementation supports a more limited set of options than the full-featured standard library version. Refer to our 
<a href="https://github.com/cs107e/cs107e.github.io/blob/master/cs107e/include/printf.h">printf.h</a> header file to know exactly what your version is required to support.</p>

<p>The ordinary characters in the input string are copied unchanged to the output string. The input string can also contain formatting codes that are placeholders for values to be inserted in the output string. For each formatting code, the requested conversion is applied to the associated argument and then written to the output string.</p>

<p>Your implementation must support these formatting codes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> %c   single character
 %s   string
 %d   signed decimal integer (optional width)
 %x   unsigned hexadecimal integer (optional width)
 %p   pointer
 %%   output a percent sign
</code></pre></div></div>

<p>For formatting codes <code class="highlighter-rouge">%c</code> and <code class="highlighter-rouge">%s</code>, no processing is needed to ‚Äúconvert‚Äù characters and strings, the character or string argument is copied as-is to the output string.</p>

<p>For the integer formatting codes <code class="highlighter-rouge">%d</code> and <code class="highlighter-rouge">%x</code>, the integer value is converted to a string representation using your handy <code class="highlighter-rouge">unsigned_to_base</code> and 
<code class="highlighter-rouge">signed_to_base</code> helper functions.  The optional width such as <code class="highlighter-rouge">%03d</code> or <code class="highlighter-rouge">%05x</code>can be specified to set the minimum number of characters in the converted string. The width is a non-negative decimal number and must be specified with a leading 0. For example, <code class="highlighter-rouge">"%014x"</code> outputs its unsigned integer argument as a hexadecimal string of at least 14 characters (padded with zeros on the left as necessary).</p>

<p>The <code class="highlighter-rouge">%p</code> format outputs an address as a width-8 hexadecimal string prefixed with 0x, e.g. <code class="highlighter-rouge">0x20200004</code>.</p>

<p>The <code class="highlighter-rouge">snprintf</code>and <code class="highlighter-rouge">printf</code> functions take a variable number of arguments, one argument for each formatting code in the format string. To access those additional arguments, you use C‚Äôs <code class="highlighter-rouge">&lt;stdarg.h.&gt;</code> interface. Read more about <a href="#varargs">Variadic functions</a> further down in this writeup.</p>

<p>These functions return the number of characters written if they fit or the number of characters that would have been written if there were space.</p>

<p><a name="varargs"></a></p>
<h4 id="variadic-functions">Variadic functions</h4>

<p><code class="highlighter-rouge">printf</code> and <code class="highlighter-rouge">snprintf</code> are functions that take a variable number of arguments.
C has standardized the way to access variadic functions using the <code class="highlighter-rouge">stdarg.h</code> interface.
Here is an example.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <code class="highlighter-rouge">sum</code> has one fixed argument <code class="highlighter-rouge">n</code>, followed by some number of
additional arguments, indicated by the <code class="highlighter-rouge">...</code> in its parameter list. 
For example, the call <code class="highlighter-rouge">sum(4, 100, 0, 5, 2)</code> contains one fixed argument, 4
(number of values to sum), and four additional arguments, 100, 0, 5, and 2.</p>

<p>The implementation of the <code class="highlighter-rouge">sum</code> function demonstrates how to use <code class="highlighter-rouge">stdarg.h</code>.</p>

<p>The variable <code class="highlighter-rouge">ap</code> is declared of type <code class="highlighter-rouge">va_list</code>.  This variable is initialized
using <code class="highlighter-rouge">va_start</code>, which is passed the last named argument. In this case, we
tell <code class="highlighter-rouge">va_start</code> that <code class="highlighter-rouge">n</code> is the last argument before the variable arguments
begin.</p>

<p>Then we loop over the <code class="highlighter-rouge">n</code> arguments, fetching each argument using <code class="highlighter-rouge">va_arg(ap,
type)</code>. In the <code class="highlighter-rouge">sum</code> example, the variable arguments are all of <code class="highlighter-rouge">int</code> type, but
the type can be different per-argument by changing what type is used in
<code class="highlighter-rouge">va_arg</code>. When we are done processing all of the variable arguments, we call
<code class="highlighter-rouge">va_end(ap)</code> to clean up after ourselves.</p>

<p>Note that because of obscure rules in the C standard about ‚Äú<a href="http://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls">default argument
promotions</a>‚Äù,
you cannot ask <code class="highlighter-rouge">va_arg</code> for the <code class="highlighter-rouge">char</code> type. Instead you must ask it for an
<code class="highlighter-rouge">int</code> and then cast the <code class="highlighter-rouge">int</code> to a <code class="highlighter-rouge">char</code>.</p>

<p>For additional information about <code class="highlighter-rouge">stdarg</code>, read the <a href="http://en.wikipedia.org/wiki/Stdarg.h">Wikipedia page on
stdarg.h</a>.</p>

<h2 id="strategies-for-success">Strategies for success</h2>

<p>Having read up to here, you may feel a bit overwhelmed by all that lays before you. It is a big job, but it will be much more tractable if you break it down into manageable tasks and tackle one at a time. Developing an appropriate decomposition and identifying a good path to follow from start to finish can be tricky, so read on for our guidance on strategies that we know work well.</p>

<h3 id="order-of-attack">Order of attack</h3>

<h4 id="1-strings-module">1. strings module</h4>

<p>Definitely start here. Each string function is a small task that can be implemented and tested independently. As you write each function, brainstorm test cases that cover a range of use cases. Add those tests into <code class="highlighter-rouge">tests/test_strings_printf.c</code> and use <code class="highlighter-rouge">make test</code> to build and run the test program. Don‚Äôt move on to the next function until the current one is fully vetted and debugged.</p>

<ul>
  <li><code class="highlighter-rouge">strlen</code> and <code class="highlighter-rouge">strcmp</code> are the simplest and make a great starting point for practice with string handling. These are critical functions that you will later depend on. What are some test cases you can use now to ensure these functions will be robust and reliable when you need them?</li>
  <li><code class="highlighter-rouge">memset</code> and <code class="highlighter-rouge">memcpy</code> are generic functions to set/copy raw data. The interface is written in terms of <code class="highlighter-rouge">void*</code> to allow any type data to be manipulated but internally you can simply cast to <code class="highlighter-rouge">char*</code> and treat as a sequence of raw bytes. Don‚Äôt assume this data ends with a null char, only an actual C-string will have a null terminator.</li>
  <li>Tackling <code class="highlighter-rouge">strlcat</code> at this point allows it to make use of <code class="highlighter-rouge">strlen</code> and <code class="highlighter-rouge">memcpy</code> (assuming they are thoroughly tested)</li>
  <li>Working through <code class="highlighter-rouge">strtonum</code> will reinforce your understanding of the difference between the ASCII character ‚Äò5‚Äô and the integer value 5 and what is needed to convert from string form to integer value. You will soon implement a similar conversion in the opposite direction.</li>
  <li>We cannot over-emphasize the importance of <a href="#testing">testing</a> as you go. Attempting to implement <code class="highlighter-rouge">printf</code> on top of an unreliable/untested strings library is an arduous task, as you must debug all of the code simultaneously and untangle complex interactions. In contrast, implementing <code class="highlighter-rouge">printf</code> on top of
a robust strings library is much more straightforward. Because of your thorough testing, you can be confident that the strings library does its job correctly and focus your attention on debugging only the new code being added.</li>
</ul>

<p>Congratulations are now in order! Having finished the strings module, you start on the printf module with a collection of very useful string functions and important lessons about strings under your belt (such as understanding the relationship between pointers and arrays, being aware of need to take care with the null terminator, and so).</p>

<h4 id="2-conversion-helper-functions">2. conversion helper functions</h4>

<p>Start with the two <code class="highlighter-rouge">xxx_to_base</code> helper functions. These small but mighty operations convert a number to a string representation (the inverse of the conversion performed by <code class="highlighter-rouge">strtonum</code>).</p>

<ul>
  <li>At first, focus on conversion to base 10 into an adequately-sized buffer. Postpone handling hexadecimal, minimum width and bufsize truncation until after you have the basics working.</li>
  <li>Pro-tip: building the string in reverse (e.g. from the least significant digit to the most) allows the logic to be somewhat cleaner.</li>
  <li>When ready to add support for hexadecimal, don‚Äôt copy/paste to create a second nearly identical conversion, one for each base! Repeated code means more code to write, debug, test, and maintain; a lose-lose all around.
Instead, identify how to unify into a single implementation that flexibly allows for either base.</li>
  <li>Similarly, you need both a signed and unsigned conversion function, 
but rather than duplicate code between the two, consider how you can call 
the <code class="highlighter-rouge">unsigned</code> function from the <code class="highlighter-rouge">signed</code> function.</li>
  <li>These helpers are going to do the heavy lifting of the number formatting for printf, so be sure to test them very thoroughly in all variations.</li>
</ul>

<h4 id="3-implement-snprintf">3. Implement snprintf</h4>

<p>You are now ready to tackle <code class="highlighter-rouge">snprintf</code>. Trying to implement all of its functionality in one go is extremely difficult and can
quickly lead to a mess of complicated code that is hard to debug or get right. The way to tame the complexity is to advance in small steps with constant testing as you go.</p>

<ul>
  <li>Be sure that your <code class="highlighter-rouge">strcmp</code> is rock-solid. Your tests are likely to be formed by calling <code class="highlighter-rouge">snprintf</code> to write a formatted string into a buffer, followed by an assert that calls <code class="highlighter-rouge">strcmp</code> to confirm the contents written to the buffer match the expected.</li>
  <li>Start by implementing <code class="highlighter-rouge">snprintf</code> with no support for formatting codes, it only outputs ordinary characters.  You can test simple examples such as <code class="highlighter-rouge">snprintf(buf, bufsize, "Hello, World!")</code>.</li>
  <li>Add support for the simplest formatting codes first, just <code class="highlighter-rouge">%%</code> and <code class="highlighter-rouge">%c</code>. You can now test examples like <code class="highlighter-rouge">snprintf(buf, bufsize, "%c%c = 100%% fresh", 'C', 'S')</code>.</li>
  <li>Formatting code <code class="highlighter-rouge">%s</code> is up next. Be sure to remember the functions you have in your string module that can help. For example, a function that could be used to append onto a string seems like it would be rather useful (hint!).</li>
  <li>When you move on to <code class="highlighter-rouge">%d</code> and <code class="highlighter-rouge">%x</code>, your conversion helpers will be ready and waiting. Postpone handling the optional width until after the basic conversions work. When reading the width from the input string, remember that you already wrote a function that converts a string of digits to integer value (hint!)</li>
  <li>The pointer <code class="highlighter-rouge">%x</code> is easy-peasy, as it is just a special case of the integer conversion (hint!).</li>
  <li>You can make the simplifying assumption that you will never be asked to construct an output string of length greater than 1024 characters (regardless of the size of the destination buffer). If you allocate a temporary buffer of this maximum size on the stack and write the full output string into it, you can then copy what fits from the temporary buffer into the final destination as a way to neatly handle the truncation as needed to fit the destination buffer.</li>
</ul>

<p>Getting to a working <code class="highlighter-rouge">snprintf</code> is the big hill to get over in this assignment. Once you have that, all that remains is re-factoring and layering. You are in the homestretch!</p>

<h4 id="4-refactor-into-vsnprintf">4. Refactor into <code class="highlighter-rouge">vsnprintf</code></h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">printf</code> function needs the same functionality as <code class="highlighter-rouge">snprintf</code>. However 
since <code class="highlighter-rouge">snprintf</code> takes a variable number of arguments, you cannot call it directly 
from <code class="highlighter-rouge">printf</code>.  You must create a shared helper function <code class="highlighter-rouge">vsnprintf</code> (that takes a
<code class="highlighter-rouge">va_list</code> parameter), which you can then call from both <code class="highlighter-rouge">snprintf</code> and <code class="highlighter-rouge">printf</code>.
Refactoring means moving most of your <code class="highlighter-rouge">snprintf</code> code into <code class="highlighter-rouge">vsnprintf</code> and then changing <code class="highlighter-rouge">snprintf</code> to call <code class="highlighter-rouge">vsnprintf</code>. Once you have completed this refactor, confirm you are still passing all of your previous tests.</p>

<h4 id="5-implement-printf">5. Implement <code class="highlighter-rouge">printf</code></h4>
<p>Adding <code class="highlighter-rouge">printf</code> is a piece of cake. It declares a stack array of the maximum output length (1024), calls <code class="highlighter-rouge">vsnprintf</code> to fill that array with the formatted output string, and hands the string over to <code class="highlighter-rouge">uart_putstring</code>. Having thoroughly tested <code class="highlighter-rouge">snprintf</code>/<code class="highlighter-rouge">vsnprintf</code>, you will not likely need many new tests for <code class="highlighter-rouge">printf</code>, since it is built on the same substrate that you have already confirmed correct.</p>

<p>It is time üï∞ for a serious Happy Dance üôå and an epic üéº that celebrates your amazing feats! You did it! üèÜ We hope you will enjoy the fruit üçé of your labors üí™ for a long time to come!</p>

<p><a name="testing"></a></p>
<h3 id="testing-advice">Testing advice</h3>
<p>Students who struggled in the past generally wrote too much code
before testing it. Instead you want to approach the work by dividing in tiny
increments, making a small, testable improvement each time. If the latest changes
don‚Äôt work, you‚Äôll know exactly where to look for the mistake. This strategy will save you a lot of time and heartache.  To quote Dawson Engler, Systems Programmer Extraordinaire:</p>

<blockquote>
  <p>Engler‚Äôs theorem of <strong>epsilon-steps</strong>: 
Given a working system <em>W</em> and a change <em>c</em>,  as <em>c</em> ‚Üí Œµ  the time <em>T</em> it takes to figure out why <em>W</em> + <em>c</em> doesn‚Äôt work goes to 0 (<em>T</em> ‚Üí 0).</p>
</blockquote>

<p>After taking each epsilon-step in your code, immediately turn your attention to testing and debugging it. What test case can you add to <code class="highlighter-rouge">tests/test_strings_printf.c</code> to confirm that the code you just added is working correctly? It may require multiple test cases to get at different parts of the behavior. Add those tests now and don‚Äôt move on until you pass them all.</p>

<p>Never delete a test! Sometimes a later change will cause a test that was previously passing to backslide. If you have removed or commented out the test, you won‚Äôt realize the bug has resurfaced. Instead, accumulate all tests in <code class="highlighter-rouge">tests/test_strings_printf.c</code> and keep them active. Every subsequent run will re-validate against the entire test suite and alert you to any regression.</p>

<p>Review the function specifications in the <code class="highlighter-rouge">strings.h</code> and <code class="highlighter-rouge">printf.h</code> header files and be sure that your test cases have full coverage of the specified behavior, including any edge cases or required error handling. If your own testing gets there ahead of the autograder, you can find and fix your bugs before submitting to its rigorous scrutiny.</p>

<p>In <code class="highlighter-rouge">tests/test_strings_printf.c</code>, we want to see a comprehensive test suite that exercises each function in the strings module and all formatting options mix-and-match for printf and variants. There is a lot of ground to cover! Grading will include an evaluation of the effectiveness of your tests, along with our feedback to help you to develop and refine this critical skill.</p>

<p>Our specifications make some simplifying assumptions relative to the standard library. Your functions need only handle calls that are valid according to our assumptions: e.g. exactly and only these formatting codes, base is always be 10 or 16, the width specified must begin with a zero, the width will never be negative, the format string is well-formed and so on. You do not have to detect/handle/reject calls that violate these assumptions. We will not test on such inputs and your tests do not need to consider these cases.</p>

<h3 id="debugging-advice">Debugging advice</h3>
<p>One unfortunate circularity with trying to test printf is the
lack of a working printf to help you debug.  Here are a couple of strategies you may want to consider:</p>

<ul>
  <li>Run your program under gdb in simulation mode and use gdb commands to
  step and print variables to observe your program‚Äôs operation. We strongly encourage you to invest in building up your gdb chops now ‚Äì this investment will really pay off! Be mindful of the differences between the simulator and the actual Pi. (review exercise 4d of <a href="/labs/lab3/#4d-differences-under-simulation">Lab3</a> if you need a refresher)</li>
  <li>Liberal use of <code class="highlighter-rouge">assert()</code> tests. For example, you can test the output
written by <code class="highlighter-rouge">signed_to_base</code> matches the expected output by asserting the two
strings <code class="highlighter-rouge">strcmp</code> as equal. Note that the version of <code class="highlighter-rouge">assert</code> used from here forward calls <code class="highlighter-rouge">uart_putstring</code> to print out details (i.e. line number, failed expression), so you are no longer limited to interpreting red and green smoke signals.</li>
  <li>A somewhat more complicated arrangement is to debug using our <code class="highlighter-rouge">printf</code> from <code class="highlighter-rouge">libpi.a</code> You can use our <code class="highlighter-rouge">printf</code> in conjunction with yours if you first disambiguate the names. Here‚Äôs how:
    <ul>
      <li>Rename all of your functions in <code class="highlighter-rouge">printf.c</code> to add <code class="highlighter-rouge">my_</code> prefix, e.g. <code class="highlighter-rouge">my_printf</code> and <code class="highlighter-rouge">my_signed_to_base</code>.</li>
      <li>Change all references throughout your code to match your renamed functions (e.g.  <code class="highlighter-rouge">my_printf</code> calls <code class="highlighter-rouge">my_vsnprintf</code> and so on).</li>
      <li>After renaming your versions, you can now use <code class="highlighter-rouge">printf</code> to access to the libpi version. For example, in <code class="highlighter-rouge">tests/test_strings_printf.c</code> you call <code class="highlighter-rouge">my_printf</code> to test your function, and within your <code class="highlighter-rouge">my_printf</code> implementation, you can call <code class="highlighter-rouge">printf</code> to output internal values
for debugging. 
<!-- This partial will open warning/danger callout box  --></li>
    </ul>
  </li>
</ul>

<div style="background-color:#ffcccc; color:#993333; border-left: 5px solid #993333;margin: 5px 25px; padding: 5px;">

  <p><strong>WARNING:</strong> Our implementation of <code class="highlighter-rouge">printf</code> will call on <strong>your</strong> string functions in <code class="highlighter-rouge">strings.c</code>. You should be certain that your string functions are robust for this path to work. Also be careful that you call the <code class="highlighter-rouge">my_</code> versions in your tests. A slip-up may cause you to mistakenly conclude your version is working when you were in fact testing our version, not your own.</p>
</div>

<h2 id="extension-disassembler">Extension: disassembler</h2>
<p>After completing printf, there may not be much bandwidth left for going further, but we think this extension is particularly neat and hope we can inspire a few of you to go for it!</p>

<p>The extension is to put your shiny new <code class="highlighter-rouge">printf</code> to work in writing a program that can disassemble itself. The binary-encoded instructions for the currently executing program are stored in memory starting at address <code class="highlighter-rouge">0x8000</code>. Each instruction is encoded as an unsigned int. Here is a diagram of the bitwise breakdown for a data processing instruction:</p>

<p><img src="images/data_processing.png" alt="data processing instruction" /></p>

<p>Reading from left to right, the upper four <code class="highlighter-rouge">cond</code> bits indicate conditional execution, the next three bits are <code class="highlighter-rouge">000</code> indicate this is a data processing instruction with an immediate operand 2, the four <code class="highlighter-rouge">opcode</code> bits determine which kind of operation (add, subtract, etc), the <code class="highlighter-rouge">S</code> bit determines whether the flags are set, and so on.</p>

<p>In lecture, Pat asked you to play the role of <em>assembler</em> by translating an instruction such as  <code class="highlighter-rouge">add r3, r4, r5</code> into <code class="highlighter-rouge">e0843005</code>. The reverse process is a <em>disassembler</em> which picks apart the bits of the encoded instruction <code class="highlighter-rouge">e0843005</code> to print out <code class="highlighter-rouge">add r3, r4, r5</code>.  The extension is to automate this disassembly process and produce output like that shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
0x00008074: e0 43 30 05    add r3, r4, r5
0x00008078: eb 00 01 c9    bl 87a4
...
</code></pre></div></div>

<p>You <em>could</em> use your bit-masking superpowers to pick apart an encoded instruction but a simpler way is to define a C bitfield. Open the file <code class="highlighter-rouge">disassemble.c</code> given in the starter code to see an example.</p>

<p>Your extension should be capable of decoding the most common variants of the data processing and branch instructions. The ARM instruction set has a remarkably regular encoding, so you can catch a good chunk of all instructions with just a few cases. If you want to get fancier, try decoding load/store and load/store multiple (i.e. push and pop).</p>

<p>Refer to the <a href="/readings/armisa.pdf#page=2">ARM ISA documentation</a> for details on the instruction encodings. Another useful resource is this <a href="https://cseweb.ucsd.edu/~ricko/CSE30/ARM_Translation_Guide.pdf">ARM guide from USCD</a> which breaks down the bits in the encoding.</p>

<p>Don‚Äôt worry about making special cases for oddballs. For any instructions you don‚Äôt decode, print the encoded value and skip to the next.</p>

<p>Print the sequence of disassembled instructions starting from address <code class="highlighter-rouge">0x8000</code> and continuing for 100 instructions or so.  Some of the data you encounter may not be instructions at all (e.g. data values can be intermixed into the instructions). Don‚Äôt worry about those, just decode the first 100 4-byte values as though each was an instruction.</p>

<p>Create a new <code class="highlighter-rouge">assign3-extension</code> branch and write your code in the <code class="highlighter-rouge">disassemble.c</code> file. Use the target <code class="highlighter-rouge">make disassemble</code> to build and test on the Pi. Compare your output to the contents of <code class="highlighter-rouge">disassemble.bin.list</code> (this is the disassembly produced by the <code class="highlighter-rouge">objdump</code> too) to see how good a job your disassembler is doing. To submit for grading, make a separate pull request for extension branch.</p>

<p>You just wrote a program that dissects itself from the inside ‚Äì how meta and awesome is that! We will offer more credit on this extension as it is more challenging than the previous ones; a great implementation deserves to be generously rewarded!üéñ</p>

<h2 id="submit">Submit</h2>
<p>The deliverables for <code class="highlighter-rouge">assign3-basic</code> are:</p>

<ul>
  <li>implementation of the <code class="highlighter-rouge">strings.c</code> and <code class="highlighter-rouge">printf.c</code> modules</li>
  <li>your comprehensive tests for all strings and printf functions in <code class="highlighter-rouge">tests/test_strings_printf.c</code></li>
</ul>

<p>Submit the finished version of your assignment by making a git ‚Äúpull request‚Äù,
following the steps given in the <a href="/assignments/assign0/">Assignment 0 writeup</a>.
Make separate pull requests for your basic and extension
submissions.</p>

<p>The automated checks ensure that we can successfully build your C
code and will be able to properly test and grade it. CI verifies that:</p>

<ul>
  <li><code class="highlighter-rouge">apps/print_pinout.c</code> is unchanged</li>
  <li><code class="highlighter-rouge">make</code> and <code class="highlighter-rouge">make test</code> successfully build</li>
  <li><code class="highlighter-rouge">make test</code> also successfully builds with the unchanged version of the test program in the starter</li>
</ul>

<h2 id="grading">Grading</h2>

<p>To grade this assignment, we will:</p>

<ul>
  <li>Verify that your project builds correctly, with no warnings (see Note 1 below)</li>
  <li>Run automated tests that thoroughly exercise the functionality of your <code class="highlighter-rouge">strings.c</code> and <code class="highlighter-rouge">printf.c</code> modules. These tests will touch on all required features of the module. (see Note 2 below)</li>
  <li>Go over the tests you added to <code class="highlighter-rouge">tests/test_strings_printf.c</code> and evaluate them for thoughtfulness and completeness in coverage.</li>
  <li>Review your code and provide feedback on your design and style choices.</li>
</ul>

<p>Note 1: The automated tester will <strong>deduct half a point for any warnings generated
when compiling your code</strong>. Warnings are the way the compiler draws attention to a code passage that isn‚Äôt an outright error but appears suspect. Some warnings are mild/harmless, but others are critically important. If you get in the habit of keeping your code compiling cleanly, you‚Äôll never miss a crucial message in a sea of warnings you are casually ignoring. You may want to consider adding the flag <code class="highlighter-rouge">-Werror</code> to CFLAGS in your Makefile.
This converts all warnings into hard errors, which block the build and guarantees no warnings will be overlooked and left unresolved.</p>

<p>Note 2: If your modules have failures on the automated tests, we will report those to you by filing issues.  To promote the practice of fixing your bugs, you will have the opportunity to re-submit with corrections for these issues for a
partial refund of the points originally deducted.
Furthermore, fixing bugs in your modules now will put you in a better place to earn
the full system bonus at the end of the quarter. The system bonus points are awarded for submitting a working system using entirely your own code written for the assignments.</p>


  </div>
  <div class="toc-column col-lg-2 col-md-2 col-sm-2 hidden-xs">
    <div id="toc" class="toc" data-spy="affix" data-offset-top="0"></div>
  </div> 
</div>

  <script src="/_assets/tocbot.min.js"></script>
  <link rel="stylesheet" href="/_assets/tocbot.css">

  <script>
    tocbot.init({
      // Where to render the table of contents.
      tocSelector: '#toc',
      // Where to grab the headings to build the table of contents.
      contentSelector: '#main_for_toc',
      // Which headings to grab inside of the contentSelector element.
      headingSelector: 'h2, h3, h4',
    });
  </script>



  </div>
  <div class="footer navbar-default navbar-static-bottom">
    <p style="font-size: 65%; color:green; text-align:center;">
      <i>CS107e Winter 2020 &middot; Site generated 2020-04-19 20:35</i>
  </p>
</div> 
</body>

  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  
</html>