<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="/_assets/site.css" rel="stylesheet">
    <link href="/_assets/favicon.png" rel="icon" type="image/png">
    <title>CS107E Assignment 7: System Monitor with Interrupts</title>
  </head>

<body>
  <!-- Include this HTML partial to set up navbar -->

<nav class="navbar navbar-inverse" role="navigation">
  <div class="navbar-header">
  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
    <!-- hamburger -->
    <span class="sr-only">Toggle navigation</span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>

  <img class="navbar-brand navbar-brand-image" src="/_assets/berry.png" >
  <a class="navbar-brand" href="/">CS107e Winter 2020</a>
  </div>

  <div class="navbar-collapse collapse">
    <ul class="nav navbar-nav navbar-right">
      <li><a href="/">Home</a></li>
      <li><a href="/assignments">Assignments</a></li>
      <li><a href="/labs">Labs</a></li>
      <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="#">
            Resources
          <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="/about/">About the course</a></li>
            <li><a href="/policies/">Policies</a></li>
            <li><a href="/schedule/">Schedule</a></li>
            <li><a href="/guides/">Guides</a></li>
            <li><a href="/project_gallery/">Project gallery</a></li>
            <li><a href="/demos/">External demos</a></li>
            <li><a href="/resources/">External resources</a></li>
          </ul>
        </li>
      <li><a href="https://github.com/cs107e/cs107e.github.io">Repository</a></li>
    </ul>
  </div>
</nav>


  <div class="container" style="max-width:55em;">
    <h1 class="title">Assignment 7: System Monitor with Interrupts</h1><hr>
    
  <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="main_for_toc">
    
<p><img src="https://media.giphy.com/media/B1uajA01vvL91Urtsp/giphy.gif" alt="speed typing" width="60%" style="float:right;" /></p>

<p><em>Written by Philip Levis, updated by Julie Zelenski</em></p>

<!-- If duedate set in front_matter, use that, otherwise calculate based on n*weeks + assign1 due -->

<p><b>Due: Tuesday, March 03 at  6:00 pm</b></p>

<hr />
<h3 id="goals">Goals</h3>

<p>With all your hard work on the previous assignments, you have schooled your Raspberry Pi in how to read input from a keyboard and respond to your commands via a graphical console display. 
For the <em>pi√®ce de r√©sistance</em> you‚Äôll upgrade your keyboard driver so that you can type as fast as the wind without dropping characters.</p>

<p>In completing this assignment you will have:</p>

<ul>
  <li>built a responsive system to process events as interrupts</li>
  <li>used an interrupt-safe data structure to correctly share data across regular and interrupt code</li>
</ul>

<p>Those of you reaching the stretch goal for the complete system bonus will also:</p>

<ul>
  <li>bundle the collection of modules you‚Äôve written into a comprehensive library for implementing a bare-metal system on the Pi</li>
  <li>have constructed a complete system of your own top to bottom: your console running on your library</li>
</ul>

<p><em>The amount of new code needed for this assignment is much less than in previous weeks to give you a bit of breathing room to revisit any previous modules that need attention and claim that complete system bonus. You can do it!</em></p>

<p>This work completes the transformation of your Raspberry Pi into a standalone computer, ready to be extended and improved in your final project. Right on!</p>

<h2 id="looking-ahead-final-project">Looking ahead: final project</h2>

<p>It‚Äôs also time to start planning for your final project. The <a href="/assignments/project/">project writeup</a> has the full schedule of dates to get on your calendar. The first step is forming teams. Let us know you‚Äôre going to partner with using this <a href="https://docs.google.com/forms/d/e/1FAIpQLSdJ9iKbXPDn7J8q0O-EVg3ihsTR9pB9C5L52gx_PXp-ER2nUw/viewform?usp=sf_link">Google form</a>. Please submit the form by <strong>Monday March 2nd</strong>.</p>

<h2 id="get-starter-files">Get starter files</h2>
<p>Change to the <code class="highlighter-rouge">cs107e.github.io</code> repository in your <code class="highlighter-rouge">cs107e_home</code> and do a <code class="highlighter-rouge">git pull</code> to ensure your courseware files are up to date.</p>

<p>To get the assignment starter code, change to your local repository, fetch any changes from the remote and switch to the assignment basic branch:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/cs107e_home/assignments
$ git fetch origin
$ git checkout assign7-basic
</code></pre></div></div>

<p>You should also verify you have the up-to-date contents for all of your modules: <code class="highlighter-rouge">timer.c</code>, <code class="highlighter-rouge">gpio.c</code>,<code class="highlighter-rouge">strings.c</code>, <code class="highlighter-rouge">printf.c</code>, <code class="highlighter-rouge">malloc.c</code>, <code class="highlighter-rouge">backtrace.c</code>, <code class="highlighter-rouge">keyboard.c</code>, <code class="highlighter-rouge">shell.c</code>, <code class="highlighter-rouge">fb.c</code>, <code class="highlighter-rouge">gl.c</code>, and <code class="highlighter-rouge">console.c</code>.  If you are missing changes from a previous assignment branch (e.g. commits from a regrade submission), have your <code class="highlighter-rouge">assign7-basic</code> checked out and use merge to incorporate changes from the desired branch (e.g. <code class="highlighter-rouge">git merge assign6-basic</code>).</p>

<p><strong>Pay careful attention to the assignment 7 Makefile</strong>: The starter Makefile assumes that you are going for the complete system bonus and <code class="highlighter-rouge">MY_MODULES</code> is set to use all of your own modules. If you need to use the reference implementation for some modules, you must edit the Makefile to remove them.  If you fix those issues and are ready to add the modules back in, you must edit the Makefile to re-list them.</p>

<p>When submitting assign 7, be sure the Makefile is set for the configuration you intend to be graded. We will test your submission using the modules you have listed in the Makefile.  If <code class="highlighter-rouge">MY_MODULES</code> lists all 11 modules, your work will be evaluated as complete and will be considered for the system bonus. If you do not have confidence in one or more of your modules, remove them from <code class="highlighter-rouge">MY_MODULES</code> and the reference module(s) will be used when testing and grading your work. Your submission will not be eligible for the bonus.</p>

<h2 id="basic-part">Basic part</h2>

<p>The basic part of the assignment is to rework your PS/2 keyboard driver to be interrupt-driven. The keyboard interface is unchanged, but its internal implementation changes from a polling strategy to one using interrupts.</p>

<p>The version of <code class="highlighter-rouge">keyboard_read_scancode</code> you wrote for assignment 5 loops calling <code class="highlighter-rouge">gpio_read</code> on the clock GPIO until it sees the level transition from high to low. If your code doesn‚Äôt happen to be reading the GPIO at the essential moment, the event is lost. If you instead arrange for an interrupt to be generated by each falling edge, the interrupt handler can jump in and grabs the data bit before it passes by and store it for later processing by  <code class="highlighter-rouge">keyboard_read_scancode</code>.</p>

<p>First, read over the code in the starter <code class="highlighter-rouge">tests/test_keyboard_interrupts.c</code> and try it out with your existing keyboard driver. You should see that any keys typed while the test program is paused inside <code class="highlighter-rouge">timer_delay</code> will be missed. Employing interrupts will fix this.</p>

<h3 id="1-set-up-keyboard-interrupts">1) Set up keyboard interrupts</h3>
<p>First, configure interrupts to be triggered on every falling edge on the clock line. The additions to do this are relatively small, but the code needs to be just right. Go slow and pay close attention to the details. Bring your most methodical approach to debugging any issues.</p>

<ul>
  <li>Review the lab 7 exercises on handling button presses via an interrupt. The code that you wrote in lab serves as a model for what to do now.</li>
  <li>In <code class="highlighter-rouge">keyboard.c</code>, add a <code class="highlighter-rouge">clock_edge</code> interrupt handler function for an event on the keyboard clock gpio.  Be sure that that the handler clears the event so that it will not repeatedly re-trigger. Have this first version of <code class="highlighter-rouge">clock_edge</code> simply output a single char <code class="highlighter-rouge">uart_putchar('#')</code> and increment a global counter. Whenever the count hits a multiple of 11 (the numbers of bits in a PS/2 packet), output a space char.</li>
  <li>In your <code class="highlighter-rouge">keyboard_init</code> function, enable event detection on the falling edge of the clock line and attach <code class="highlighter-rouge">clock_edge</code> as a handler.</li>
  <li>Edit the <code class="highlighter-rouge">main</code> function of the test program <code class="highlighter-rouge">tests/test_keyboard_interrupts.c</code> to make the appropriate calls to initialize interrupts at start and globally enables interrupts once all is ready.</li>
  <li>Run the test program to confirm your handler function receives interrupts. Typing a regular key sends 3 packets (1 for key press and 2 for key release) so should generate 33 interrupts in total. Your handler function should output 3 groups of 11 hash characters per typed key.</li>
</ul>

<p>Remember, the code in an interrupt handler should be simple and streamlined. This is both because you don‚Äôt want to delay/miss the processing of the next interrupt and because debugging interrupts
can be so hard. A complex <code class="highlighter-rouge">printf</code> in your handler would likely cause you to miss a closely-following event and could lead you on a wild goose chase to find the ‚Äúbug‚Äù that caused it.</p>

<h3 id="2-gather-a-ps2-scancode">2) Gather a PS/2 scancode</h3>
<p>The falling edge of PS/2 clock edge indicates that now is the time to grab a bit from the PS/2 data line.</p>

<p><img src="images/ps2.png" alt="ps2 clock" /></p>

<p>Change <code class="highlighter-rouge">clock_edge</code> to read from the PS/2 data line and based on the value read, output <code class="highlighter-rouge">uart_putchar('0')</code> or <code class="highlighter-rouge">uart_putchar('1')</code> instead of a hash char. Build and run the test program . The output should show the 11 bits in the packet sent by the keyboard.</p>

<p>Now edit <code class="highlighter-rouge">clock_edge</code> to gather those 11 bits as they arrive to form a scancode. Be sure to re-purpose your earlier code that implements the logic to synchronize on the start bit and 
verify the parity and stop bits.</p>

<p>Upon receiving the last bit of a well-formed packet, the completed scancode is ready to be enqueued in step 3 below.</p>

<p>(As a side note, our reference version of the keyboard module supports reading in either polling mode or by interrupts. It defaults to polling and can be switched into interrupt mode by calling the function <code class="highlighter-rouge">keyboard_use_interrupts()</code>. Your keyboard does not need to support this. You can directly re-purpose your previous code to read scancodes to instead read via interrupts without trying to preserve the old way of doing things.)</p>

<h3 id="3-use-ring-buffer">3) Use ring buffer</h3>

<p>Almost there! The last task is to use a shared queue to communicate the received scancodes from <code class="highlighter-rouge">clock_edge</code> to the <code class="highlighter-rouge">keybaord_read_scancode</code> function.  The queue we use is the interrupt-safe ring buffer design as described in lecture. Review the header and source files (<code class="highlighter-rouge">cs107e/include/ringbuffer.h</code> , <code class="highlighter-rouge">cs107e/src/ringbuffer.c</code>) to learn more about this data structure.</p>

<ul>
  <li><code class="highlighter-rouge">keyboard_init</code> should initialize the new ring buffer queue.</li>
  <li>When <code class="highlighter-rouge">clock_edge</code> receives the final bit of a packet, it should enqueue the scancode to the queue.</li>
  <li><code class="highlighter-rouge">keyboard_read_scancode</code> should take scancodes from the queue.   If the queue is non-empty, it immediately dequeues the first scancode and returns it. If the queue is empty, it will spin waiting for the queue to become non-empty, i.e. waiting for <code class="highlighter-rouge">clock_edge</code> to enqueue a scancode. It then dequeues the scancode and returns it. Note that <code class="highlighter-rouge">keyboard_read_scancode</code> always returns a scancode‚Äî either a saved scancode that was received previously or waits for the next scancode to arrive.</li>
</ul>

<p>You should now be able to run your same console shell application as in
assignment 6, and all should work as before, except this time you never miss a key. Each typed key is immediately enqueued by the interrupt handler for later processing by the console when ready.</p>

<p>You now have a fully operational console that uses the full power of your
hardware! What you have running is not too far from an Apple II computer.</p>

<h3 id="4-need-for-speed">4) Need for speed?</h3>
<p>Your new interrupt-driven keyboard driver is guaranteed to never drop a key, but even a moderately fast typist can still enqueue a decent number of keys during a slow console redraw that makes for a longish wait as the console works through the backlog. <strong>This is perfectly fine as our requirement is that the console receive all typed characters and correctly draw and respond to input</strong>. But, ‚Ä¶ if the performance exercise from lab 7 has roused your interest in optimization, we‚Äôd love to see what you can do to improve the responsiveness. A few ideas to consider:</p>

<ul>
  <li>Inner loops are the first place to look for speed-up opportunities (e.g. hoisting out redundant work, streamlining operations, loop unrolling). With a million pixels on the line, cutting 10 instructions per pixel totals to a full second of time saved.</li>
  <li>Every call to <code class="highlighter-rouge">gl_draw_char</code> calls <code class="highlighter-rouge">font_get_char</code> to re-extract the character from the font bitmap. Try doing the extract just once per unique char and cache to re-use later?</li>
  <li>Vertical scroll is particularly painful because of the need to redraw the entire screen. Rather than recalculate/redraw all the text, you could copy the previously drawn pixels upward. Or wackier, what about a framebuffer variant that simply adjusts the y_offset to get scrolling for ‚Äúfree‚Äù and defers paying the cost of a full redraw until hit virtual bottom?</li>
</ul>

<h2 id="complete-system-bonus">Complete system bonus</h2>
<p>The <code class="highlighter-rouge">make lib</code> target of the Makefile bundles the files named in <code class="highlighter-rouge">MY_MODULES</code> into a single library <code class="highlighter-rouge">libmypi.a</code>.</p>

<p>If your <code class="highlighter-rouge">libmypi.a</code> uses all your own modules for this assignment (no use of reference modules) and your interrupt-driven console works correctly, 
you receive a full 10-point bonus. This is a big reward for a big 
accomplishment! If you fulfill this bonus, you‚Äôve successfully built a complete
computer system from the ground up, and every line of code for that system is sitting in your assignments folder. Congratulations!</p>

<p>To be considered for the bonus, <code class="highlighter-rouge">libmypi.a </code>must use your own code
for all modules. We will not re-test your individual modules to the extent that they were
tested when grading each assignment, but all shell/console functionality must work correctly. This means, for example, your <code class="highlighter-rouge">printf</code> must handle
printing padded hexadecimal numbers (which are needed for <code class="highlighter-rouge">peek</code>), but
need not necessarily handle negative values perfectly (since they are
not used by the shell).</p>

<p>That <code class="highlighter-rouge">libmypi.a</code> library packages up all your battle-tested code in a form ready to be incorporated into any future project.  The directory 
<code class="highlighter-rouge">cs107e.github.io/assignments/assign7/libmypi-usage</code> contains a template project that demonstrates how to build an application using your <code class="highlighter-rouge">libmypi.a</code>.</p>

<p>To start a new project, make a copy of the template project and copy in
your <code class="highlighter-rouge">libmypi.a</code>. file  Use <code class="highlighter-rouge">make install</code> to build and run.  You can now program your Pi almost like an Arduino with this high-level library you wrote.</p>

<h2 id="extensions">Extensions</h2>

<p>We have two proposed
extensions. Choose one OR the other (you do not need to do both).</p>

<h3 id="1-profiler">1) Profiler</h3>

<p>One extension is to add profiling support to your shell.
A <em>profiler</em> is a developer tool that tracks where in the code a program is spending its execution time.</p>

<p>If diagnosing how to improve in a slow program, your first task would be to observe the program and measure where it spends most of its time.
Speeding up those sections of the code will have the greatest
effect on the overall run time.</p>

<p>There is a simple and clever way to do this using a <em>sampling</em> strategy.
Configure the ARM timer to periodically interrupt your program.
On each timer event, you record a sample of the PC. Recall that the argument to the interrupt handler is the PC of the instruction that was about to execute at the time of the interruption.
The probability that a given value of the PC is the argument to the interrupt handler
is proportional to the time spent executing that instruction.
The more often that an instruction is executed,
the more times the interrupt handler will be called with that PC.
A profile is created by creating a histogram that counts
the number of times the program is interrupted at each PC.</p>

<p>For this extension, you will configure periodic timer interrupts to sample the PC and print a histogram of the PC values. You will also add a new command to your shell run your profiler.</p>

<p>The header file <code class="highlighter-rouge">cs107e/include/gprof.h</code> declares the interface to the
profiling functions.</p>

<p>The profiling will maintain an array of counters, one for each instruction address in the text (code) section.</p>

<p>There is a known address where the text section starts (what value is
that again?), but to know the extent of the text, you will need to edit the linker map to mark the end.  It may help to revisit <a href="/labs/lab4/">lab4</a> for
information on linker maps.</p>

<p>Open the <code class="highlighter-rouge">memmap</code> file and, patterning after how symbols are used to mark the bounds of the bss section, add a symbol to identify the end of the text section. Use this symbol in <code class="highlighter-rouge">gprof_init</code> to compute the correct amount of space needed to have a counter for each instruction in the text section. All of those counters should be initialized to zero at the start of profiling.</p>

<p><code class="highlighter-rouge">gprof_init</code> configures a timer interrupt scheduled for the
interval defined in <code class="highlighter-rouge">gprof.c</code> using our <code class="highlighter-rouge">armtimer</code> module.  (See
the header file
<a href="https://github.com/cs107e/cs107e.github.io/blob/master/cs107e/include/armtimer.h">armtimer.h</a>).  Attach the function <code class="highlighter-rouge">gprof_handler</code> as an interrupt handler. <code class="highlighter-rouge">gprof_handler</code> takes one
argument, the value of the PC at the time of the interrupt, and will increment the counter for that value of the PC.</p>

<p>Add the command <code class="highlighter-rouge">profile [on | off | status | results]</code> to
your shell commands. <code class="highlighter-rouge">profile on</code> should initialize or zero-out all profile
counts and start profiling (enable timer interrupts). <code class="highlighter-rouge">profile off</code> should stop
the profiling (disable timer interrupts). <code class="highlighter-rouge">profile status</code> should print <code class="highlighter-rouge">Status:
on</code> or <code class="highlighter-rouge">Status: off</code>, depending on whether the profiler is on or off,
respectively. <code class="highlighter-rouge">profile results</code> should print current (if status is on) or most
recent (if status is off) counts to the debugger console using the <code class="highlighter-rouge">gprof_dump</code>
function. The <code class="highlighter-rouge">gprof_dump</code> should print the highest 10 counts to the console (in any order).</p>

<p>The final touch for your profiler is to provide the function name that each high-count instruction belongs to. If you remember the <code class="highlighter-rouge">name_of</code> function you wrote for assignment 4, the compiler has embedded each function‚Äôs name as a string of characters before its first instruction. You can find the function‚Äôs name by walking backwards in memory from the instruction to find the ‚Äúmagic‚Äù byte that marks where name is stored.</p>

<p>For each high-count instruction, you should report the address of the instruction, the name of the function it belongs to, the instruction offset within the function, and the count of samples recorded for that instruction. Thus your profiler results look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x0000ae0c uart_putchar+36: 13358
0x0000be1c timer_get_ticks+16: 23219
0x0000be5c timer_delay_us+24: 36209
</code></pre></div></div>

<p>Cool, you now have a profiler!</p>

<h3 id="2-ps2-mouse-and-paint-application">2) PS/2 mouse and paint application</h3>

<p>For this extension, you‚Äôll write a small paint application using your
<code class="highlighter-rouge">libmypi.a</code>.</p>

<p>Make a <code class="highlighter-rouge">paint</code> subdirectory in your assign7 directory. We‚Äôve
provided one starter file, <code class="highlighter-rouge">mouse.c</code>, but you‚Äôll add files around it
so that the <code class="highlighter-rouge">paint</code> directory is actually a complete standalone
application, with its own <code class="highlighter-rouge">Makefile</code> and everything.</p>

<p>Copy the starter project files in
<code class="highlighter-rouge">cs107e.github.io/assignments/assign7/libmypi-usage</code> into <code class="highlighter-rouge">paint</code>,
and copy your finished <code class="highlighter-rouge">libmypi.a</code> in as well. Add the starter file <code class="highlighter-rouge">mouse.c</code> to the project and edit the Makefile to add <code class="highlighter-rouge">mouse.o</code> to the list of <code class="highlighter-rouge">OBJECTS</code>.</p>

<p>Make sure you can build and run the ‚ÄúHello, world‚Äù application right
now.</p>

<p>Your first job is to write a driver for a PS/2 mouse. There is a box of PS/2 mice on the shelf in the B21 lab room. Borrow a mouse from us while working on the extension, but please return  it to us when done. Read these pages on the
<a href="https://web.archive.org/web/20180124072221/http://www.computer-engineering.org/ps2protocol/">PS/2 protocol</a> and
<a href="https://web.archive.org/web/20171214135004/http://www.computer-engineering.org/ps2mouse/">PS/2 mouse specifically</a>
for details on how to talk to a mouse. Connect the power/ground/clock/data pins from the PS/2 plug on the mouse to your Pi.</p>

<p>The functions <code class="highlighter-rouge">mouse_read_scancode</code> and <code class="highlighter-rouge">clock_edge</code> are the near-identical twins to the parallel functions in keyboard, the only change being to use the GPIO pins for mouse clock and data GPIO pins instead of keyboard. The mouse <code class="highlighter-rouge">clock_edge</code> gathers data bits and enqueues a scancode to a ring buffer to be dequeued by <code class="highlighter-rouge">mouse_read_scancode</code>, same as you did for keyboard.</p>

<p>The function <code class="highlighter-rouge">mouse_write</code> implements the other half of the PS/2 protocol:
sending a packet from the Pi to the mouse. We must first set the mouse into ‚Äúdata reporting mode‚Äù so it sends scancodes on mouse movement. See ‚ÄúHost-to-Device
Communication‚Äù in the PS/2 protocol documentation for the full write
process. Here are some notes:</p>

<ul>
  <li>
    <p>You need to temporarily reconfigure the mouse‚Äôs clock and data GPIO pins as output pins so you can pull them low
when needed. ‚ÄòRelease‚Äô (set as input again) the clock line after you
delay 100 us and write the start bit, and release the data line after
you write the parity bit and see a falling clock edge.</p>
  </li>
  <li>
    <p>To write a packet, you wait for a falling clock edge
11 times (before sending each of 8 data bits, before sending the
parity bit, before releasing the data line, and before reading the
acknowledgment bit from the mouse). After that last falling clock
edge, spin until the data line goes high (that‚Äôs the end of the ack
bit transmission).</p>
  </li>
</ul>

<p>The <code class="highlighter-rouge">mouse_init</code> functions writes to the mouse and reads its responses to perform the required mouse initialization sequence:</p>

<ol>
  <li>Write a Reset scancode to put the mouse in Reset mode.</li>
  <li>Read the ACK scancode (should be 0xFA).</li>
  <li>Read the BAT Successful scancode (should be 0xAA).</li>
  <li>Read the Device ID scancode (should be 0x00).</li>
  <li>Write the Enable Data Reporting scancode.</li>
  <li>Read the ACK scancode (should be 0xFA).</li>
</ol>

<p>Run <code class="highlighter-rouge">mouse_init</code> from <code class="highlighter-rouge">main.c</code> and confirm that the mouse responds
with the expected scancodes. After data reporting has been enabled, the mouse should send movement scancodes as you move it.</p>

<p>The higher-level <code class="highlighter-rouge">mouse_read_event</code> function is implemented on top of <code class="highlighter-rouge">mouse_read_scancode</code> to convert the low-level scancode into a mouse movement event. See the <code class="highlighter-rouge">cs107e/include/mouse.h</code> file for declaration of the
<code class="highlighter-rouge">mouse_event_t</code> structure, and consult the PS/2 mouse page to find how
scancode bits map to event details. Be careful about the 9-bit two‚Äôs
complement representation of distances!</p>

<p>Using your shiny new mouse driver, implement a paint application
in <code class="highlighter-rouge">main.c</code>. When you run paint, it will initialize the graphics library, and then loop, reading mouse events and drawing on the screen in response.</p>

<p>It should be possible to:</p>

<ul>
  <li>draw stuff [like a smiley face :-)] by holding down the left mouse
button and moving the mouse</li>
  <li>when not holding down the button, move some mouse pointer-like shape around on
the screen without disrupting stuff that‚Äôs been painted</li>
</ul>

<p>Other than that, the details of the UI are up to you. Describe in your
README how we should use your paint program!</p>

<h2 id="submit">Submit</h2>
<p>The deliverables for <code class="highlighter-rouge">assign7-basic</code> are:</p>

<ul>
  <li>A reworked <code class="highlighter-rouge">keyboard.c</code> module that uses interrupts</li>
  <li>Completed versions of all your previous modules (if to be considered for system bonus)</li>
  <li>Your tests in <code class="highlighter-rouge">tests/test_keyboard_interrupts.c</code></li>
</ul>

<p>Submit the finished version of your assignment by making a git ‚Äúpull request‚Äù. Make separate pull requests for your basic and extension submissions.</p>

<p>Make sure you add all the necessary source files to Git so that we can
clone your assignment and build and run it. If you are aiming for the complete system bonus, double-check that your Makefile lists all modules in <code class="highlighter-rouge">MY_MODULES</code> and that the updated versions of your files are added and committed to the repository. If you are submitting the paint extension, be sure all of the needed files in your paint subdirectory are committed as well.</p>

<p>One means to verify what was included with your submission is to push and then clone it again from GitHub in a separate <code class="highlighter-rouge">assign7-clone</code> folder.  Build and run from this clone to be sure all essential files are present.</p>

<p>The automated checks make sure that we can run your C
code and test and grade it properly, including swapping your tests for
ours.</p>

<p>CI verifies that:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">apps/interrupts_console_shell.c</code> is unchanged</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">make</code> and <code class="highlighter-rouge">make test</code> successfully build</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">make test</code> also successfully builds with the unchanged version of the test program in the starter</p>
  </li>
</ul>

<h2 id="grading">Grading</h2>
<p>To grade this assignment, we will:</p>

<ul>
  <li>Verify that your submission builds correctly, with no warnings. Warnings and/or build errors result in automatic deductions. Clean build always!</li>
  <li>Interactively test your full console program running with a PS/2 keyboard and HDMI monitor.</li>
  <li>Review your code and provide feedback on your design and style choices.</li>
</ul>

<h2 id="course-learning-goals">Course learning goals</h2>

<p><strong>Three cheers for YOU!</strong> üëèüëè üëè This is <strong>your</strong> computer system, the one you built yourself from the ground up. Each line of code is there because you put it there, you know what it does, and why it is needed. We are in awe of the effort you put in to arrive here and hope you are as proud of your work as we are.</p>

<p>Reflecting on where you started, it has been an impressive journey. Take stock of the progress you have made on mastering these course learning goals:</p>

<p>‚úîÔ∏é <strong>To understand how computers represent information, execute programs, and control peripherals</strong></p>
<ul>
  <li>Binary and hexadecimal number systems, machine encoding of instructions</li>
  <li>Memory layout, pointers, arrays, structs</li>
  <li>ARM assembly, use of registers, instruction control flow</li>
  <li>Runtime use of stack and heap memory</li>
  <li>Memory-mapped I/O to access to peripherals, device drivers (keyboard, display)</li>
  <li>Interrupts, simple multi-processing</li>
</ul>

<p>‚úîÔ∏é <strong>To master command-line programming tools and the C programming language</strong></p>
<ul>
  <li>Build tools (assembler, compiler, linker, make, bootloader)</li>
  <li>Implementation of standard C library functions (strings, printf, malloc, graphics)</li>
  <li>Strategies for testing and debugging code, using gdb</li>
  <li>Establishing a productive and effective programming workflow</li>
</ul>

<p>Bring these skills into the final project, mix with your creativity and initiative, and something fabulous will surely result. We‚Äôre looking forward to it!</p>

<p><img src="images/yoda.gif" alt="yoda" /></p>

<p>`</p>

  </div>
  <div class="toc-column col-lg-2 col-md-2 col-sm-2 hidden-xs">
    <div id="toc" class="toc" data-spy="affix" data-offset-top="0"></div>
  </div> 
</div>

  <script src="/_assets/tocbot.min.js"></script>
  <link rel="stylesheet" href="/_assets/tocbot.css">

  <script>
    tocbot.init({
      // Where to render the table of contents.
      tocSelector: '#toc',
      // Where to grab the headings to build the table of contents.
      contentSelector: '#main_for_toc',
      // Which headings to grab inside of the contentSelector element.
      headingSelector: 'h2, h3, h4',
    });
  </script>



  </div>
  <div class="footer navbar-default navbar-static-bottom">
    <p style="font-size: 65%; color:green; text-align:center;">
      <i>CS107e Winter 2020 &middot; Site generated 2020-04-19 20:35</i>
  </p>
</div> 
</body>

  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  
</html>