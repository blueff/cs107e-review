<div align="center">
  <h1>
    Computer Systems from the Ground Up
  </h1>
</div>

My study note of the awesome course [CS107E Winter 2020](http://cs107e.github.io/).

## Table of Contents

<!-- vim-markdown-toc GFM -->

* [Week1: Introduction and Welcome](#week1-introduction-and-welcome)
  * [Raspberry Pi](#raspberry-pi)
  * [ARM processor and architecture](#arm-processor-and-architecture)
  * [Assignment 0](#assignment-0)
* [Week 2: ARM assembly and machine code](#week-2-arm-assembly-and-machine-code)
  * [Lab1](#lab1)
    * [Blink](#blink)
    * [Button](#button)
  * [Assignment1](#assignment1)
    * [A simple Larson Scanner](#a-simple-larson-scanner)
    * [Extended Larson Scanner](#extended-larson-scanner)
  * [From Assembly to C](#from-assembly-to-c)
* [Week 3: C Pointers and Arrays](#week-3-c-pointers-and-arrays)
  * [Lab2](#lab2)
    * [C to assembly](#c-to-assembly)
    * [Makefiles](#makefiles)
    * [Testing](#testing)
    * [Wire up display breadborad](#wire-up-display-breadborad)
  * [Assignment2](#assignment2)
    * [A Clock](#a-clock)
    * [Set Time Extension](#set-time-extension)
* [ARM Tips](#arm-tips)

<!-- vim-markdown-toc -->

## Week1: Introduction and Welcome

[List of electronic parts we will use in this course](https://cs107e.github.io/guides/bom/).

### Raspberry Pi

- [Pinout.xyz](https://pinout.xyz/): online website
- [Pinout.pdf](http://cs107e.github.io/guides/images/pinout.pdf): PDF document

The Raspberry Pi model we are gonna use is [Raspberry Pi 1 Model A+](https://www.raspberrypi.org/products/raspberry-pi-1-model-a-plus/).

Must stick with this version otherwise the code might not work.

The CPU model of the Pi is [BCM2835](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md) (ARM11 series, ARMv6 architecture).

Check the manual here [BCM2835 Peripherals Specification](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf).

You need to know that this manual __has a lot of errors__, must read it with [BCM 2835 Datasheet Errata](https://elinux.org/BCM2835_datasheet_errata#p96).

NOTE: __The address in the manual `0x7E...` is the logic address. We will change it to `0x20...` in the code__.

### ARM processor and architecture

- [Intro to ARM assembly](http://www.toves.org/books/arm/)
- [Awesome ARM tutorail from CSIE@NTU](https://www.csie.ntu.edu.tw/~cyy/courses/assembly/09fall/lectures/handouts/lec09_ARMisa.pdf)
- [VisUAL](https://salmanarif.bitbucket.io/visual/index.html): Visual ARM emulator

First, we need to install the arm toolchain for our Pi (compiler, assembler, linker, etc..) and the CP2012 driver. Check the [Installation Guide](http://cs107e.github.io/guides/install/).

After installation, we should have a bunch of `arm-none-eabi` tools.

```bash
cs107e git:(master) â¯ whence -a -m 'arm-none-eabi*'
/usr/local/bin/arm-none-eabi-addr2line
/usr/local/bin/arm-none-eabi-ar
/usr/local/bin/arm-none-eabi-as
/usr/local/bin/arm-none-eabi-c++filt
/usr/local/bin/arm-none-eabi-cpp
/usr/local/bin/arm-none-eabi-elfedit
/usr/local/bin/arm-none-eabi-gcc
/usr/local/bin/arm-none-eabi-gcc-4.8.3
/usr/local/bin/arm-none-eabi-gcc-ar
/usr/local/bin/arm-none-eabi-gcc-nm
/usr/local/bin/arm-none-eabi-gcc-ranlib
/usr/local/bin/arm-none-eabi-gcov
/usr/local/bin/arm-none-eabi-gdb
/usr/local/bin/arm-none-eabi-gprof
/usr/local/bin/arm-none-eabi-ld
/usr/local/bin/arm-none-eabi-ld.bfd
/usr/local/bin/arm-none-eabi-nm
/usr/local/bin/arm-none-eabi-objcopy
/usr/local/bin/arm-none-eabi-objdump
/usr/local/bin/arm-none-eabi-ranlib
/usr/local/bin/arm-none-eabi-readelf
/usr/local/bin/arm-none-eabi-run
/usr/local/bin/arm-none-eabi-size
/usr/local/bin/arm-none-eabi-strings
/usr/local/bin/arm-none-eabi-strip
```

What is the meaning of `arm-none-eabi`? It turns out that:

> Unix cross compilers are loosely named using a convention of the form `arch[-vendor][-os]-abi`.

> The arch refers to the target architecture, which in our case is ARM. The vendor nominally refers to the
toolchain supplier. The os refers to the target operating system, if any, and is used to decide which libraries
(e.g. newlib, glibc, crt0, etc.) to link and which syscall conventions to employ. The abi specifies which
application binary interface convention is being employed, which ensures that binaries generated by different
tools can interoperate.

So `none` menas we are not targeting any operating system here, aka we are in "bare metal". And `eabi` means the ABI for the ARM architecture.

### Assignment 0

This is for the official students, I have nothing to do here ðŸ˜œ.

## Week 2: ARM assembly and machine code

[ARM Instruction Set Architecture](http://cs107e.github.io/readings/armisa.pdf).

From this documentation, we can know that __every ARM instruction can be conditionally executed__. This is a big difference from X86.

[ARM immediate value encoding](https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/#play-with-it).

> The ARM instruction set encodes immediate values in an unusual way. It's typical of the design of the processor architecture: elegant, pragmatic, and quirky. Despite only using 12 bits of instruction space, the immediate value can represent a useful set of 32-bit constants.

Basically, instead of using 12-bit to represent a number, ARM uses 8-bit for the number and 4-bit for rotation. By using this approach, it can represent a large set of useful 32-bit values.

### Lab1

#### Blink

Let's give the world some light!

![](./assets/blink.gif)

#### Button

Tada! ðŸŽ‰ What a fun button ever! NOTE: We need to have a 10k pull-up resistor. If you are not familiar with this concept, this is a [fine explanation](https://learn.sparkfun.com/tutorials/pull-up-resistors/all).

![](./assets/button.gif)

### Assignment1

#### A simple Larson Scanner

1. Configure GPIO 20 ~ 27 to output mode
2. Set current gpio pin for a while then clear it
3. Update current gpio pin, need to handle the edge case
4. Go back to step 2

Here is the code [larson.s](./week2/assign1/larson.s).

![](./assets/larson.gif)

#### Extended Larson Scanner

First, we need a way to control brightness. I thought about directly configuring the output voltage for a GPIO pin but it seems impossible.

So Let's do it the other way. We can control the time of the high level in a period to control the power supplied. The more power, the brighter LED. Actually this is a standard technique called [Pulse Width Modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation).

Let's try that, implement a simple test in [brightness.s](./week2/assign1/brightness.s).

We decrease the duty cycle (time of high level in the period) for GPIO 20, 21 and 22 one by one and see if their brightness has any difference.

![](./assets/brightness.jpeg)

Yes they do! So the implementation of extended Larson scanner is obvious now.

Check the code [larson-extended.s](./week2/assign1/larson-extended.s).

![](./assets/larson-extended.gif)

### From Assembly to C

- [Compiler Explorer](https://gcc.godbolt.org): A neat interactive tool to see translation from C to assembly

After writing some ARM assembly code and switching to using C, this is the first time I ever think that C is so so so superior and powerful!

Long live C!

> C is quirky, flawed, and an enormous success â€” Dennis Ritchie

> C gives the programmer what the programmer wants; few
restrictions, few complaints â€” Herbert Schildt

> C: A language that combines all the elegance and power of assembly
language with all the readability and maintainability of assembly
language â€” Unknown

A sample Makefile for compiling base-metal C for ARM:

```makefile
NAME = myprogram
CFLAGS = -Og -Wall -std=c99 -ffreestanding
LDFLAGS = -nostdlib -e main

.PRECIOUS: %.elf %.o

all : $(NAME).bin

%.bin: %.elf
	 arm-none-eabi-objcopy $< -O binary $@

%.elf: %.o
	 arm-none-eabi-ld $(LDFLAGS) $< -o $@

%.o: %.c
	 arm-none-eabi-gcc $(CFLAGS) -c $< -o $@
```

## Week 3: C Pointers and Arrays

About NULL-terminated strings, Poul-Henning Kamp wrote an essay [The Most Expensive One-byte Mistake](https://queue.acm.org/detail.cfm?id=2010365).

Does C do it wrong? I don't know. Using `(len, ptr)` will certainly incur other problems, like how long is the length field? Is it fixed or is it flexible?

Since the spirit of C is trying to be simple and close to the machine, maybe NULL-terminated string is the way to go.

If we want to implement the `(len, ptr)` pattern, it's trivially easy. Check [sds in Redis](https://github.com/antirez/redis/blob/unstable/src/sds.h#L51).

### Lab2

#### C to assembly

`make codegen.list` and see what compiler does! Let your curiosity be your guide!

#### Makefiles

I've noticed that the loop counter variable `c` in `blink.c` is not `volatile`.

```c
for (int c = DELAY; c ! = 0; c--); // wait
```

Is that OK? We can find out.

Disassemble the code and we can see the loop is there, it hasn't been optimized out.

But if we change the gcc flag `-Og` to `-O2`, the loop is gone.

So as a conclusion: __If your busy loop doesn't work, check the optimization level and whether or not the loop counter is volatile__.

_What is the purpose for each of the CFLAGS?_

`arm-none-eabi-gcc -v --help` is our best friend.

_What happens if you just type make? Which commands will execute?_

It will make the first target just as you have typed `make all`.

_If you modify blink.c and run make again, which commands will rerun? What part of each target indicates the prerequisites?_

All three commands, two `arm-none-eabi-gcc` and one `arm-none-eabi-objcopy`. The right part after the colon indicates the prerequisites.

_What do the symbols $< and $@ mean?_

`$@` refers to the left part of the rule, before the `:`.

`$<` refers to the first element in the right part of the rule, after the `:`.

And by the way, `$^` refers to all elements in the right part of the rule, after the `:`.

#### Testing

Using two built-in LEDs to indicate whether something is wrong.

- GPIO 47: greet act LED
- GPIO 35: red power LED

Always test, test and test the program!

#### Wire up display breadborad

Just follow the instructions and remember: small step with tests!

Since I don't have short jumpers, it looks kind of messy. But the structure is clear.

![](./assets/display-breadboard.jpeg)

### Assignment2

#### A Clock

This [Interactive demo of segment display](http://www.uize.com/examples/seven-segment-display.html) can be very helpful when constructing bit patterns.

Note: For the input pin, we are not going to implement the pull-up by ourselves. __It turns out that Raspberry Pi has built-in support for pull-up and pull-down__. Check the manual on page 100.

```c
static volatile u32 *gp_pud = (u32 *)0x20200094;
static volatile u32 *gp_pud_clk = (u32 *)0x20200098;
static void gpio_set_pullup(uint pin)
{
  uint bank = pin / 32;
  uint shift = pin % 32;

  *gp_pud = 2;

  for (volatile int i = 0; i < 150; i++) ;

  *(gp_pud_clk + bank) = 1 << shift;

  for (volatile int i = 0; i < 150; i++) ;

  *gp_pud = 0;
  *(gp_pud_clk + bank) = 0;
}
```

Much more convenient now! ðŸ˜„

Here comes our cute home-made clock.

![](./assets/clock.gif)

#### Set Time Extension

First, we need to design the _interface_. It's actually very straight forward.

Out clock has three modes.

- Running mode: it just ticks every second
- Setting mode: configure each digit in this mode
- Halt mode: it stops and displays fixed numbers

Red button for `start/stop` and blue button for switching from setting mode.

Let's see the actions and transitions from each mode:

- First, the clock shows the initial '----'
- Press red button, it starts running
  - Press red button again, it stops
  - Press blue button, it enters setting mode, see detail below
- Press blue button, it enters setting mode
  - Press blue button to move the "focus". Exiting to halt mode if the focus reaches to the end.
  - Press red button to increase the number of the current digit

What a cool clock!

When we try to capture the button press event, we will soon found a problem.

> When reading button presses on the Pi, you will quickly realize that pressing the button once may cause the value on the GPIO pin to change multiple times. This is due to physical characteristics of the button mechanism which cause the button circuit to open and close multiple times during a press.

Let's see the demo:

![](./assets/button-unstable.gif)

We can clearly see that on button press triggers multiple increments.

This can be solved by __debouncing__.

> To address this issue, implement debouncing by checking whether the value change on the GPIO pin corresponds to an actual button press or one of these spurious events. This can be done by checking that the GPIO pin reads the button press value for a long enough time (that is, these spurious events will change the GPIO value quickly, meaning if you check the value of the pin as pressed, then wait a bit longer and see it as unpressed, that means it was a spurious event).

The main idea is that we check the input level, wait a little bit time (we have to experiment to find out the time we need), then we check again. If both checks give us a low level, the button is pressed.

Our little button works now!

![](./assets/button-debounced.gif)

This is our final clock, check the full code [week3/assign2/apps/clocl.c](./week3/assign2/apps/clock.c).

![](./assets/clock-extended.gif)

NOTE: If you encounter this error: _undefined reference to `__aeabi_idivmod`_, that means you have used some division operations and need to link to `libgcc.a`.

## ARM Tips

- Disassemble object file: `arm-none-eabi-objdump -D input.o`.

- Disassemble binary file: `arm-none-eabi-objdump -b binary -D -marm input.bin`.
